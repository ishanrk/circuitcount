use std::collections::BTreeSet;
use std::fs;
use std::path::Path;

use anyhow::{Context, Result, anyhow, bail};

use crate::field::Fp;
use crate::rng::XorShift64;

#[derive(Debug, Clone)]
pub struct Cnf {
    pub num_vars: usize,
    pub clauses: Vec<Vec<i32>>,
}

impl Cnf {
    pub fn parse_dimacs(input: &str) -> Result<Self> {
        let mut header_vars = None::<usize>;
        let mut header_clauses = None::<usize>;
        let mut data_tokens = Vec::<i32>::new();

        for line in input.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('c') {
                continue;
            }
            if line.starts_with('p') {
                let parts: Vec<_> = line.split_whitespace().collect();
                if parts.len() != 4 || parts[1] != "cnf" {
                    bail!("invalid DIMACS problem line: {line}");
                }
                header_vars = Some(
                    parts[2]
                        .parse::<usize>()
                        .context("invalid DIMACS variable count")?,
                );
                header_clauses = Some(
                    parts[3]
                        .parse::<usize>()
                        .context("invalid DIMACS clause count")?,
                );
                continue;
            }
            for tok in line.split_whitespace() {
                data_tokens.push(tok.parse::<i32>().context("invalid literal token")?);
            }
        }

        let num_vars = header_vars.ok_or_else(|| anyhow!("missing DIMACS header"))?;
        let expected_clause_count =
            header_clauses.ok_or_else(|| anyhow!("missing DIMACS clause count"))?;
        let mut clauses = Vec::<Vec<i32>>::new();
        let mut current = Vec::<i32>::new();

        for lit in data_tokens {
            if lit == 0 {
                if !current.is_empty() {
                    validate_clause(&current, num_vars)?;
                    clauses.push(current.clone());
                    current.clear();
                }
            } else {
                current.push(lit);
            }
        }
        if !current.is_empty() {
            bail!("DIMACS data ended without terminal 0 for final clause");
        }

        if clauses.len() != expected_clause_count {
            bail!(
                "DIMACS clause count mismatch: header says {}, parsed {}",
                expected_clause_count,
                clauses.len()
            );
        }

        Ok(Self { num_vars, clauses })
    }

    pub fn to_dimacs(&self) -> String {
        let mut out = String::new();
        out.push_str("c generated by ffsat\n");
        out.push_str(&format!("p cnf {} {}\n", self.num_vars, self.clauses.len()));
        for clause in &self.clauses {
            for lit in clause {
                out.push_str(&format!("{lit} "));
            }
            out.push_str("0\n");
        }
        out
    }

    pub fn max_clause_width(&self) -> usize {
        self.clauses.iter().map(|c| c.len()).max().unwrap_or(0)
    }

    pub fn aggregate_degree_upper_bound(&self) -> usize {
        self.max_clause_width().max(2)
    }

    pub fn eval_clause_unsat_indicator(&self, clause: &[i32], point: &[u8]) -> Result<Fp> {
        let mut acc = Fp::one();
        for &lit in clause {
            let lit_val = literal_eval(lit, point)?;
            acc *= Fp::one() - lit_val;
        }
        Ok(acc)
    }

    pub fn aggregate_poly_eval(
        &self,
        point: &[u8],
        clause_weights: &[Fp],
        boolean_weights: &[Fp],
    ) -> Result<Fp> {
        if point.len() != self.num_vars {
            bail!("point length {} != num_vars {}", point.len(), self.num_vars);
        }
        if clause_weights.len() != self.clauses.len() {
            bail!(
                "clause weight length {} != clause count {}",
                clause_weights.len(),
                self.clauses.len()
            );
        }
        if boolean_weights.len() != self.num_vars {
            bail!(
                "boolean weight length {} != num_vars {}",
                boolean_weights.len(),
                self.num_vars
            );
        }

        let mut acc = Fp::zero();
        for (j, clause) in self.clauses.iter().enumerate() {
            let u = self.eval_clause_unsat_indicator(clause, point)?;
            acc += clause_weights[j] * u;
        }
        for i in 0..self.num_vars {
            let x = Fp::new(point[i] as u64);
            acc += boolean_weights[i] * (x * (x - Fp::one()));
        }
        Ok(acc)
    }
}

fn validate_clause(clause: &[i32], num_vars: usize) -> Result<()> {
    if clause.is_empty() {
        bail!("empty clause is not supported in this prototype");
    }
    for &lit in clause {
        if lit == 0 {
            bail!("zero literal should only terminate clauses");
        }
        let idx = lit.unsigned_abs() as usize;
        if idx == 0 || idx > num_vars {
            bail!("literal {} out of range [1, {}]", lit, num_vars);
        }
    }
    Ok(())
}

pub fn literal_eval(lit: i32, point: &[u8]) -> Result<Fp> {
    let idx = lit.unsigned_abs() as usize - 1;
    if idx >= point.len() {
        bail!("literal index {} out of range", idx + 1);
    }
    let x = Fp::new(point[idx] as u64);
    if lit > 0 { Ok(x) } else { Ok(Fp::one() - x) }
}

pub fn bits_to_index(bits: &[u8]) -> usize {
    let mut idx = 0usize;
    for (i, &bit) in bits.iter().enumerate() {
        idx |= (bit as usize) << i;
    }
    idx
}

pub fn load_cnf(path: &str) -> Result<Cnf> {
    let content =
        fs::read_to_string(path).with_context(|| format!("cannot read CNF file {path}"))?;
    Cnf::parse_dimacs(&content)
}

pub fn load_witness(path: &str, num_vars: usize) -> Result<Vec<u8>> {
    let content =
        fs::read_to_string(path).with_context(|| format!("cannot read witness file {path}"))?;
    let mut bits = Vec::new();
    for tok in content.split_whitespace() {
        match tok {
            "0" => bits.push(0u8),
            "1" => bits.push(1u8),
            _ => bail!("witness must be binary, found {}", tok),
        }
    }
    if bits.len() != num_vars {
        bail!(
            "witness has {} bits but CNF requires {}",
            bits.len(),
            num_vars
        );
    }
    Ok(bits)
}

pub fn write_cnf(path: &str, cnf: &Cnf) -> Result<()> {
    if let Some(parent) = Path::new(path).parent() {
        fs::create_dir_all(parent).with_context(|| format!("cannot create {:?}", parent))?;
    }
    fs::write(path, cnf.to_dimacs()).with_context(|| format!("cannot write {}", path))?;
    Ok(())
}

pub fn write_witness(path: &str, witness: &[u8]) -> Result<()> {
    if let Some(parent) = Path::new(path).parent() {
        fs::create_dir_all(parent).with_context(|| format!("cannot create {:?}", parent))?;
    }
    let line = witness
        .iter()
        .map(|b| b.to_string())
        .collect::<Vec<_>>()
        .join(" ");
    fs::write(path, line).with_context(|| format!("cannot write {}", path))?;
    Ok(())
}

pub fn generate_planted_3sat(
    num_vars: usize,
    num_clauses: usize,
    seed: u64,
    make_unsat: bool,
) -> (Cnf, Vec<u8>) {
    let mut rng = XorShift64::new(seed);
    let witness = (0..num_vars)
        .map(|_| if rng.next_bool() { 1u8 } else { 0u8 })
        .collect::<Vec<_>>();

    let mut clauses = Vec::<Vec<i32>>::with_capacity(num_clauses + 2);
    for _ in 0..num_clauses {
        let mut picked = BTreeSet::<usize>::new();
        while picked.len() < 3 {
            picked.insert(rng.next_usize(num_vars));
        }
        let vars = picked.into_iter().collect::<Vec<_>>();
        let mut clause = Vec::<i32>::with_capacity(3);
        let mut satisfied = false;
        for &v in &vars {
            let want_true_literal = rng.next_bool();
            let lit = if want_true_literal {
                (v as i32) + 1
            } else {
                -((v as i32) + 1)
            };
            let lit_is_true = if lit > 0 {
                witness[v] == 1
            } else {
                witness[v] == 0
            };
            satisfied |= lit_is_true;
            clause.push(lit);
        }
        if !satisfied {
            let v = vars[0];
            clause[0] = if witness[v] == 1 {
                (v as i32) + 1
            } else {
                -((v as i32) + 1)
            };
        }
        clauses.push(clause);
    }

    if make_unsat && num_vars > 0 {
        clauses.push(vec![1]);
        clauses.push(vec![-1]);
    }

    (Cnf { num_vars, clauses }, witness)
}
